13/12/24 
What I Did:

Set up a local PostgreSQL database using Docker.
Created a seed.sql file for database structure and initial data.
Wrote a seed.js script to execute SQL commands programmatically using Node.js and pg.
Configured the API to connect to the local database through environment variables.
Issues Faced:

Connection Refused: The backend couldn't connect to the database due to timing issues during Docker startup.

Fixed by adding depends_on in docker-compose.yml to ensure the database starts before the backend.
SSL Error: The local PostgreSQL database didn’t support SSL connections, while the code was configured to use SSL.

Resolved by disabling SSL for local connections in connection.js and using the NODE_ENV variable to toggle settings for production and development.

16/12 
Today, I:

Set up PostgreSQL locally:

Created roles and databases (special_letter and test_special_letter).
Resolved connection issues by configuring the correct user and passwords.
Configured my test environment:

Set up a test database for Jest testing.
Added scripts to reset and seed the test database before each test.
Fixed Jest issues:

Migrated back to CommonJS (require syntax).
Ensured my tests run smoothly with proper database seeding and ordering.

4/01/25

I’ve created the logic for authorisation and authentication, but I’ve concluded that the user still needs a password. I will add it. I have also run tests to retrieve the user list. The next steps are:

Create a function to check for an existing user during authorisation.
Add a password to the authorisation logic.
Write tests for creating a new user.
Write simple error handlers.

7/01/25 

Yesterday and today, I updated database models to include password hashing, implemented secure user creation and login functionality with bcrypt, integrated JWT token generation for authentication, and refined error handling in controllers for better clarity and reliability.

10/01 

I wrote several tests for the database, including verifying if the users and letters tables were seeded correctly, and checking relationships between them. Initially, the main issue was with the user_id mapping in the letters table, which led to inconsistent associations between users and their letters.

I resolved this by ensuring consistent seeding with fixed user_id values and proper mapping using username during the seed process. I also wrote tests to retrieve all letters for a specific user and to fetch letters that could be opened in 2023. By refining the database queries and aligning the test expectations with the actual data, I ensured the relationships between the tables were functioning as intended.

I also learned that a port is not required for testing with supertest. Instead of running the server on a specific port using app.listen, I used the express app object directly in the tests. This approach avoids conflicts, such as the "address already in use" error, and ensures the tests run smoothly without relying on an active server. 
